# 문제
### 두 용액
![image](https://user-images.githubusercontent.com/25299428/154213024-edc752b4-3904-439b-9a60-f269b6e6d21d.png)


문제 접근

정렬을 하는 이유: 모든 경우의 수를 탐색하면 100000!이기 때문
투포인터를 사용하는 이유: 정렬해놓았기 때문에, 합이 0보다 크면 오른쪽의 범위를, 작으면 왼쪽의 범위를 줄일 수 있기 때문이다. 따라서 0에 가까운 값을 찾기 위해 절댓값으로 최소가 되는
시점의 포인터 값들을 저장한다.

### 후위 표기식
![image](https://user-images.githubusercontent.com/25299428/154398125-735d1e34-72fe-4ff4-88e9-fb2a89d22ce5.png)

문제 접근

스택을 사용해야 하는건 알았지만 후위 표기식 구현이 미숙해서 정답을 참고했음.. 
1. 피연산자(a,b,c)는 출력한다. 
2. 연산자는 앞 연산자(스택의 맨 위)를 살펴서 출력하거나 대기한다(스택에 넣는다, 대기 된 자료들은 나중에 대기 된 연산자가 먼저 나온다, LIFO, 스택을 이용) 
3. 연산자의 대기(스택에 push)여부는 연산자간의 우선순위에 따른다.
연산자 간의 우선순위는 '('이 최하위여야 한다. 출력하면 안되기 때문에 빼버리기 위해서이다.

### 보석 도둑
![image](https://user-images.githubusercontent.com/25299428/154398369-97670f8a-514d-4ade-979a-598247cdc6ca.png)


문제 접근

전형적인 그리디 문제. 가방에 담을 수 있는 보석 중 가장 가치가 높은 것부터 담아야 최대로 담을 수 있다.
따라서 보석을 무게가 작고, 가치가 높은순으로 정렬하여 m[i]번째 가방이 담을 수 있는 것 중에서 가치가 높은 것을 선택한다.
나의 경우 가치가 높은걸 고르기 위해 m[i]보다 작은 무게의 보석을 우선순위 큐에 담았다.
