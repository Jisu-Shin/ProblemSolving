# 기타리스트
접근
i-1번째 볼륨 값’들’ 중에서 +P[i], -P[i]을 수행한 값 중 최댓값을 출력한다. 이 때, i번째 곡을 연주할 수 없다면 -1 출력한다.
따라서 순서와 값, 두 가지를 저장하기 위해 2차원 배열 테이블을 사용한다.
dp[v][i] = i번째에 v 볼륨으로 연주가 가능한지 여부 (true or false)

```java
dp[S][0] = true; // base case
for(i=1 to N){
	for(v=0 to M){
		if(v + P[i] <= M && dp[v][i - 1] == true)
			dp[v + P[i]][i] = true;
		if(v - P[i] >= 0 && dp[v][i - 1] == true)
			dp[v - P[i]][i] = true;
	}
}
```

N번째 dp 배열에서 M부터 0까지 탐색하면서 true라면, 해당 볼륨을 출력, 없으면 -1

# 중량 제한
접근

그리디한 방법과 이분 탐색을 이용하여 해결할 수 있는데, 각각을 살펴보자

1. 그리디
문제의 조건에 한 지점에 간선이 여러 개 연결될 수 있는데, 최대 무게 제한의 간선만을 통과하는 방법이다. 이 때 탐색방법은 다익스트라, BFS 두 개 다 가능하다.
어차피 우리가 관심있는건 최대 중량이기 때문에, 시간 제한 내에 탐색이 가능하다.
2. 위의 방법을 사용하지 않고 간선을 모두 통과하려하면 시간초과가 발생한다. 따라서 이분 탐색으로 log의 복잡도를 갖도록 만들면 시간 제한 내에 가능하다.

개선할 점

Hashmap으로 하다보니 코드의 길이가 길어지는 단점이 있었다. 인상 깊은 코드는 우선순위 큐를 이용해 배열을 저장하고, predicate로 무게 제한이 작은 간선만을 탐색하는 방법이었다.
실제로도 내 답안보다 시간과 메모리를 절약한걸 확인할 수 있었다.

# 공정 컨설턴트 호석
접근

1. X시간 내에 모든 선물을 완성할 수 있는 최소 라인 수를 요구한다. 1부터 N까지 선형탐색으로 찾을 수 있지만, N이 10만이고, X가 10억이기 때문에 시간 초과가 발생할 수 있다. 따라서 log의 복잡도로 줄이기 위해 이분탐색을 사용해야 한다.

2. 최적해를 찾기 위해서는 가장 작은 라인의 공정 시간 + i번째 선물의 공정 시간으로 계산해야 한다. 따라서 우선순위 큐를 사용했다.

# 카드 게임
N이 1000이기 때문에 브루트포스를 수행하면 2^500으로 시간초과가 난다. 어떻게 연산을 줄일 수 있을까 고민하다 다이나믹 프로그래밍까지 떠올리긴 했지만 점화식을 세우기 어려웠다.

우선 이 문제는 모든 경우의 수를 탐색해야 한다. 왼쪽과 오른쪽을 고른 경우가 각각 최대 점수를 얻는게 달라지기 때문이다. 즉, 근우의 차례엔 근우의 점수가 최대가 되게 하고, 명우의 차례엔 근우의 점수가 최소가 되도록 해야 한다.

문제의 조건을 유심히 보면 부분 문제가 있는걸 알 수 있는데, dp[l][r] = l~r번째 카드 중에서 근우가 얻을 수 있는 최대 점수로 테이블을 구성하여 이미 구한 값을 재사용하도록 했다.

# 미세먼지 안녕!
미세먼지의 확산, 바람의 방향에 따른 먼지의 이동에 유의하여 구현을 해야 한다. 문제의 조건을 크게 두 가지로 나누어 구분할 수 있는데, 확산하는 함수와 먼지를 이동시키는 함수로 구분했다.
또한 유의해야할 점은 먼지가 공기청정기에 들어가면 사라지는 것에 유의하여 구현한다.
