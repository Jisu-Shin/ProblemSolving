# 문제
### 달이 차오른다, 가자.
![image](https://user-images.githubusercontent.com/25299428/155082062-df059e95-6027-46c8-a5d9-ae84b1cdfa0c.png)

문제 접근
1. 인접 행렬을 그래프로 구성할 수 있음.
2. 가중치가 없는 무방향 그래프이기 때문에 BFS로 최단 거리 메커니즘을 적용할 수 있음.
    - N, M 크기가 작아 시간제한 내에 가능
3. 열쇠를 얻은 상태를 저장해야 하기 때문에 상태 관리를 위한 데이터 공간이 필요함.
    - 방문 배열의 dimension을 2차원 -> 3차원으로 늘려 저장.
    - 비트마스킹 방법으로 저장하면 int형 변수 하나에 7가지 상태를 표현할 수 있어 효율적이다.
    - visit[row][col][stat]
4. 다음 칸을 방문하는 경우는 5가지.
    - 빈 칸, 열쇠, 벽, 문, 출구
5. 다음 칸이 문이고, 맞는 열쇠를 갖고 있다면 큐에 넣을 수 있음.

### 네트워크 복구
![image](https://user-images.githubusercontent.com/25299428/155111644-ad9794db-d3b1-412f-9c20-253c93f7ce48.png)


문제 요약

- 1번 정점부터 모든 정점들까지 최소 가중치로 탐색하는 간선의 개수, 방문 기록을 출력

문제 접근
1. N개의 노드와 가중치가 있기 때문에 인접 리스트 형태의 그래프로 나타낼 수 있음.
    - 양방향 엣지
2. 다익스트라 -> 시작 정점부터 다른 정점들까지 최소 가중치로 탐색할 수 있는 방법
3. 이미 더 짧은 경로를 알고 있다면 해당 경로를 사용하여 연산을 줄임
4. 방문 기록을 저장하기 위해 path 배열로 새 정점을 탐색할 때마다 갱신
