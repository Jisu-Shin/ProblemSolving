# 잠수함 식별
- 문제의 조건을 살펴보면, 정규표현식과 유사한 패턴임을 알 수 있다.
  정규표현식을 사용하면 코드양을 줄일 수 있어 사용했다.
# 맥주 마시면서 걸어가기
- 시작 지점부터 근처의 편의점을 들를 수 있다면, 탐색하여 진행하는 과정이 BFS와 유사했고, N의 크기가 100이하로 작기 때문에, BFS로도 충분히 해결할 수 있다고 판단했다.
  음수 좌표 값을 간편하게 처리하기 위해서 시작 지점과, 편의점, 도착 지점들을 클래스의 인스턴스로 생성하여 hashmap의 형태로 키에 넣었다.
  이후 맨해튼 거리가 1000이하라면 큐에 넣어 탐색하도록 구현했다.
# 계란으로 계란치기
- 조건을 살펴보면 상태를 기억하기 위한 재귀 호출이 필요하다는걸 눈치챌 수 있는데, 계란을 치고 내구도가 감소된 상태에서 다음 계란을 칠 지 판단하는 것, 내구도가 0이하인 계란은 더 이상 치지 않고 다음 계란으로 넘어가는 조건을 통해 판단했다.
  N의 크기가 작기 때문에 브루트포스로 전부 탐색해도 무리가 없다.
# 두 동전
- 문제를 풀기 위해 조건에 유의하여 접근해야 한다.

1. 두 개의 동전이 빠져나가는 경우는 제외한다.

2. 동전의 다음 방향에 벽이 있다면, 이동할 수 없다.

3. 두 동전은 함께 이동한다.

4. 동전의 이동 횟수가 10번을 초과하면 취소한다.

정답을 찾기 위해서는 위의 조건을 만족하는 모든 경우를 탐색해야 한다. 따라서 DFS와 유사하게 접근했다.

접근 방식

1. base case로 10번을 초과하는 경우라면 탐색을 종료한다.

2. 두 동전의 다음 좌표를 계산한다.

  2.1 두 동전이 모두 범위를 벗어난다면 탐색을 종료한다.

  2.2 하나의 동전만 범위를 벗어난다면 최소 이동 횟수를 저장하고, 탐색을 종료한다.

3. 다음 칸이 벽이라면, 원래 좌표로 값을 갱신한다.

4. 상하좌우로 탐색을 진행한다.

# 통나무 옮기기
- 통나무 옮기는 방향을 상하좌우, 회전 5가지로 구분할 수 있다. 각각의 방향으로 이동한 상태를 기억하기 위해 BFS를 사용하기 적합하다 판단했고, 다음 상태로 이동하기 전에 나무가 있는지, 범위를 벗어나지 않는지를 확인하여 탐색하면 답을 구할 수 있다.

  범위를 벗어나는 경우를 좀 더 쉽게 처리하기 위해 기존의 맵을 감싸는 영역을 나무로 저장하도록 했다.
