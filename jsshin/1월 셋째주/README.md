# 1월 셋째주



###  <img src ="https://d2gd6pc034wcta.cloudfront.net/tier/11.svg" width="25"> 출근경로 (22-01-26 AC)

https://www.acmicpc.net/problem/5569

> 실행시간 124ms

`교차로를 돈 차량은 그 다음 교차로에서 다시 방향을 바꿀 수 없다`  

위 부분을 구현하기 위해 4차원 DP\[행]\[열]\[방향(북=0, 동=1)]\[방향전환가능여부(불가=0, 가능=1) ] 를 구현하였다

아래 코드가 핵심이라 가져왔다

1,1 부터 시작으로 생각해서 DP\[H+1]\[W+1] 로 구현을 하였다

```java
for (int i = 2; i <= H; i++) {
			for (int j = 2; j <= W; j++) {
				
				// 북, 방향전환불가 = 이전 방향전환했을 때 값 가져오기
				//               이전 행 ,같은 열, 동, 방향전환가능
				dp[i][j][0][0] = dp[i - 1][j][1][1]% mod;
				// 동, 방향전환불가 = 이전 방향전환했을 때 값 가져오기
				//               같은 행 ,이전 열, 북, 방향전환가능
				dp[i][j][1][0] = dp[i][j - 1][0][1]% mod;
				
				// 북, 방향전환가능 = ( 북,방향전환불가 + 북,방향전환가능)
				dp[i][j][0][1] = (dp[i - 1][j][0][0] + dp[i - 1][j][0][1]) % mod;
				// 동 방향전환가능= ( 동,방향전환불가 + 동,방향전환가능)
				dp[i][j][1][1] = (dp[i][j - 1][1][0] + dp[i][j - 1][1][1]) % mod ;
			}
}
```



### <img src ="https://d2gd6pc034wcta.cloudfront.net/tier/11.svg" width="25"> 트리인가 (22-01-26 AC)

https://www.acmicpc.net/problem/6416

> 실행시간 128ms

트리의 특징만 검사하면 되는 문제였다 (DFS 할 필요없음...)

1.  트리의 루트노드는 1개 이하여야 한다  (노드가 없어도 트리이다 그때 루트노드는 없으므로...)
2.  정점에 들어오는 간선은 하나여야한다 (Map을 사용해 검사하였다)
3.  정점이 1개 이상일경우 , 정점의개수 = 간선의개수+1 이어야한다





### <img src ="https://d2gd6pc034wcta.cloudfront.net/tier/11.svg" width="25"> 개똥벌레 (22-01-25 AC)

https://www.acmicpc.net/problem/3020

> 실행시간 356ms

2차원배열 imos법으로 풀었는데 메모리초과가 떴다 

그래서 다른풀이를 알아보던중 O(N)으로도 풀 수 있는 방법을 보게 됐다

높이로만 1차원 배열을 만든 후 , 해당 인덱스에 값을 추가한다 

**종유석도 거꾸로 보면 아래에서 시작하므로 인덱스의 변화없이 종유석 차례에 장애물크기의 위치에 값을 추가한다 **

**높이로 1차원배열을 만들었으므로 뒤에서부터 누적합을 더해야한다**

idx = 3 인 배열에 값이 있다면 (1,2,3) 다 지나가야 하므로 장애물의 값을 구할 수 있다



### <img src ="https://d2gd6pc034wcta.cloudfront.net/tier/14.svg" width="25"> 개미굴

https://www.acmicpc.net/problem/14725

> 실행시간 132ms

규칙을 찾으면 쉽게 풀 수 있다
현재의 누적합이 다음의 숫자보다 작을 경우 +1을 해준게 정답이다



### <img src ="https://d2gd6pc034wcta.cloudfront.net/tier/15.svg" width="25"> 소수의 곱 (22-01-25 AC)

https://www.acmicpc.net/problem/2014

> 실행시간 272ms

오름차순으로 나타내기 위해 PirorityQueue를 사용했으며 

중복되는 값이 생기면 안되므로 ` if(tmpNum%ni==0) break; `조건문을 넣어줘야했다

소수들을 priorityQueue에 다 넣어주고 하나씩 빼면서 

곱한 값을 넣어주고 빼낸 값이 기존 소수로 나눠떨어지면 더 이상 곱하지 않는다 (다른 수로 만들 수 있다=중복값이 생긴다)

**곱셈이므로 숫자가 커질수있다 Long 타입으로 해야한다**



