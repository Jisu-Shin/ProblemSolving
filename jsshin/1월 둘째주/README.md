# 1월 둘째주



###  Lv 1. 신고 결과 받기

https://programmers.co.kr/learn/courses/30/lessons/92334

> 점수 100점

자료구조로 풀 수 있던 문제 

Map<String, HashSet> 구조로 푸는게 포인트인듯 하다 



### Lv 2. k진수에서 소수 개수 구하기

https://www.acmicpc.net/problem/17406

> 실행시간 276ms





### Lv 2. 양궁대회

https://programmers.co.kr/learn/courses/30/lessons/92342

> 점수 100점

테스트 23번이 계속 실패였는데 그 이유 ==>  `diff>0` 검사를 안했기때문이다

어피치와 라이언 둘이 동점(= 0 )일 경우 어피치가 승리하기 때문에 {-1}을 리턴해야한다 

처음에 중복조합으로 풀었는데 시간초과가 나서 찾아보니 최적의 상황으로 찾아봐야한다고 해서 바로 코드 수정을 했다

기존조합 풀던 형식을 조금 바꿔서 풀었다 

comb (현재 과녁 index , 남은 양궁개수) 이 재귀함수 + 최적의 상황을 합쳤다

기저조건은 과녁 index 끝까지 갔을 경우이다 

`중요` :: **과녁 index 끝까지 왔는데도 양궁이 남아있을경우 맨마지막 index에 남은 양궁을 넣어줘야한다**

그 이유는 `라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요. ` 때문이다



### Lv 3. 양과 늑대

https://programmers.co.kr/learn/courses/30/lessons/92343

> 점수 88.9



BFS로 푸는데 한번 갔던곳을 여러번 갈 수 있으므로 3차원 visited배열과

지금까지 경로를 파악하기 위해 방문한 노드 비트마스킹으로 vistied 처리하는 코드를 작성하였다

bit형식으로 vistied 처리하는 코드는 직접 손코딩하면서 이해하게 되었다 부모노드와 자식노드가 양이라면 2개를 얻을 수 있지만

부모노드가 늑대이고 자식노드 2개가 양이라면 bfs 할 때 두 노드중 자식노드 하나만 카운팅이 되기 때문이다 

순열할때 비트마스킹으로  처리한적이 있어서 바로 적용하여 문제를 풀었는데 2개의 테케를 통과하지 못했다...



### Lv 3. 파괴되지 않은 건물

https://programmers.co.kr/learn/courses/30/lessons/92344

> 점수 100점

3중 반복문으로 작성하면 효율성테스트에서 0점을 받게 된다 => O(n^3) 

imos 알고리즘을 이해하고 풀면 2중 반복문으로 풀 수 있다 => O(n^2)

가장자리만 찍어주고 페인트 칠하듯이 가로한번 세로한번 쓱 지나가면 누적합이 생긴다 

**imos 배열의 사이즈는 행과열이 기존보다 +1씩 커야한다 가장자리를 찍어야하기 때문이다**

1. 가장자리를 찍는다 
   - 시작점(r1,c1), 끝점의대각선좌표(r2+1,c1+1) ==> 동일한 값
   - 행의 끝점(r2+1,c1) , 열의 끝점 (r1,c2+1) ==> 반대값 // 이후 인덱스부터 해당 값들이 없어져야 하므로

2. 시작 열 = 1 , 이전 열과 현재 열을 더한다 (누적합)
3. 시작 행 =1 ,이전 행과 현재 행을 더한다 (누적합)

